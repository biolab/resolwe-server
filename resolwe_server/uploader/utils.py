"""Uploader utility functions."""
import pickle
import hashlib
import hmac
import json
import logging
import os
import shutil

from resolwe.utils import BraceMessage as __


def get_upload_id(session_id, file_uid, secret_key):
    """Return the session identifier used by the request."""
    # NOTE: This code path is used in multiple locations, including a
    # WSGI runner and Django's runserver command.
    # They behave differently with respect to the types of variables
    # passed into this function when run on Python 3.
    # Hence, we need to encode all variables to bytes manually.
    if not isinstance(session_id, bytes):
        session_id = session_id.encode('utf-8')

    if not isinstance(file_uid, bytes):
        file_uid = file_uid.encode('utf-8')

    if not isinstance(secret_key, bytes):
        secret_key = secret_key.encode('utf-8')

    # based on django.utils.crypto.salted_hmac
    # (commit: 9a2a52558e080f109a27d40a033a135c9d0e7e50)
    key_salt = b'file_upload_session_id'
    key = hashlib.sha1(key_salt + secret_key).digest()

    return hmac.new(key, msg=session_id + file_uid, digestmod=hashlib.sha1).hexdigest()


def pull_offset(fname):
    """Get progress from ``.status`` file."""
    try:
        with open(fname + '.status', 'rb') as f:
            return pickle.load(f)
    except IOError:
        return 0


def push_offset(fname, what):
    """Write progress to ``.status`` file."""
    try:
        with open(fname + '.status', 'wb') as f:
            return pickle.dump(what, f, -1)
    except IOError:
        pass


def _remove_file(fn):
    """Remove file and ignore if file does not exist."""
    try:
        os.remove(fn)
    except OSError as ex:
        if ex.errno != os.errno.ENOENT:
            raise


def uploader(request_method, post_data, session_id, file_uid, secret_key, upload_dir, response):
    """Receive uploaded chunks and combine them into one file.

    :param str request_method: HTTP request method
    :param dict post_data: list of paramaters retrieved in POST request
        (if aplicable, othervise ``{}``). It should contain:
        * ``_totalSize`` - size of whole file
        * ``_chunkSize`` - size of chunk
        * ``_chunkNumber`` - consecutive number of current chunk
        * ``_currentChunkSize`` - size of the current chunk (may be
            lower than ``_chunkSize``for last chunk)
        * ``file`` - content of the current chunk (part of the uploaded
            file)
        * ``filename`` - name of the uploaded file
    :param str session_id: session id of the current HTTP session
    :param str file_uid: unique identifier of the uploaded file,
        normally generated by the client
    :param str upload_dir: path to the directory where uploaded file
        will be placed
    :param func respone: function that generate appropriate HTTP
        response based on the environment where function runs
    """
    if request_method not in ['GET', 'POST']:
        logging.warning(__("Invalid HTTP request method: '{}'."), request_method)
        return response(405)

    if session_id is None or file_uid is None:
        msg = "Session-Id and X-File-Uid must be given in header"
        logging.warning(msg)
        return response(400, msg)

    upload_id = get_upload_id(session_id, file_uid, secret_key)
    filetemp = os.path.join(upload_dir, upload_id)

    offset = pull_offset(filetemp)

    if request_method == 'GET':
        return response(200, json.dumps({'resume_offset': offset}))

    try:
        content_total = int(post_data['_totalSize'])
        chunk_size = int(post_data['_chunkSize'])
        content_from = int(post_data['_chunkNumber']) * chunk_size
        content_to = content_from + int(post_data['_currentChunkSize'])

        if not os.path.exists(filetemp):
            with open(filetemp, 'wb') as f:
                f.truncate(content_total)

        with open(filetemp, 'r+b') as f:
            f.seek(content_from)
            shutil.copyfileobj(post_data['file'], f, 1024 * 1024)

        new_offset = max(content_to, offset)
        push_offset(filetemp, new_offset)

        if new_offset < content_total:
            data = json.dumps({'resume_offset': new_offset})
            return response(201, data)
        elif new_offset == content_total:
            data = json.dumps({'files': [
                {'name': post_data['filename'],
                 'temp': upload_id,
                 'size': content_total,
                 'done': True},
            ]})
            _remove_file(filetemp + '.status')
            return response(200, data)
        else:
            msg = "Upload failed: content overflow."
            logging.warning(msg)
            return response(400, msg)

    except Exception as unknown_e:  # pylint: disable=broad-except
        logging.error(__("Unexpected error occured: {}", unknown_e))
        return response(500)
